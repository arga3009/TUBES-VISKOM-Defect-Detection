# -*- coding: utf-8 -*-
"""TUBES VISKOM_Arga Kusuma Wiratama_Aditya Nur Pratama

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1USzGjc4qrb58TKe92ZLL69wT_LP0CZgi
"""

!pip install tensorflow
!pip install tf_slim
!pip install tf-models-official

import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.applications import MobileNetV3Small
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import matplotlib.pyplot as plt
from PIL import Image
import IPython.display as display
from google.colab import files
from keras.preprocessing import image
import os
import shutil
from google.colab import drive
drive.mount('/content/drive')

train_path = '/content/drive/MyDrive/VISKOM/TUBES/Dataset/train'
test_path = '/content/drive/MyDrive/VISKOM/TUBES/Dataset/test'

train_datagen = ImageDataGenerator(
    rescale=1./255,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True
)

test_datagen = ImageDataGenerator(rescale=1./255)

batch_size = 32

train_generator = train_datagen.flow_from_directory(
    train_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='binary'
)

test_generator = test_datagen.flow_from_directory(
    test_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='binary'
)

def build_detection_model(num_classes):
    model = models.Sequential([
        layers.Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)),
        layers.MaxPooling2D((2, 2)),
        layers.Conv2D(64, (3, 3), activation='relu'),
        layers.MaxPooling2D((2, 2)),
        layers.Conv2D(128, (3, 3), activation='relu'),
        layers.MaxPooling2D((2, 2)),
        layers.Flatten(),
        layers.Dense(512, activation='relu'),
        layers.Dense(1, activation='sigmoid')
    ])

    return model

num_classes = 1
detection_model = build_detection_model(num_classes)

detection_model.compile(
    optimizer='adam',
    loss='binary_crossentropy',
    metrics=['accuracy']
)

steps_per_epoch = len(train_generator)
validation_steps = len(test_generator)

history = detection_model.fit(
    train_generator,
    steps_per_epoch = steps_per_epoch,
    epochs=20,
    validation_data = test_generator,
    validation_steps = validation_steps
)

plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Training and Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

def detect_defect_in_uploaded_image(uploaded_image_path):
    img = image.load_img(uploaded_image_path, target_size=(224, 224))
    img_array = image.img_to_array(img)
    img_array = img_array / 255.0
    img_array = tf.expand_dims(img_array, 0)

    predictions = detection_model.predict(img_array)

    defect_probability = predictions[0][0]
    if defect_probability > 0.5:
        return "No Defect"
    else:
        return "Defect"

uploaded_image = files.upload()
uploaded_image_path = next(iter(uploaded_image.keys()))
display.display(display.Image(filename=uploaded_image_path))
result = detect_defect_in_uploaded_image(uploaded_image_path)
print(result)